// Import necessary modules and libraries.
const { ethers, upgrades } = require('hardhat');
const { assert } = require('chai');
const { utils } = require('ethers');

// Start defining your test suite.
describe('Integer Overflow Simulation', function () {
  let integerOverflowVulnerabilityExample;
  let owner;

  // Before running the tests, deploy the contract and set up initial conditions.
  before(async function () {
    [owner] = await ethers.getSigners();

    // Deploy the contract and assign the instance to a variable.
    console.log('Deploying IntegerOverflowVulnerabilityExample contract...');
    IntegerOverflowVulnerabilityExample = await ethers.getContractFactory('IntegerOverflowVulnerabilityExample', owner);
    integerOverflowVulnerabilityExample = await IntegerOverflowVulnerabilityExample.deploy();
    await integerOverflowVulnerabilityExample.deployed();
  });

  // Test case: Perform deposit and withdraw without causing an integer overflow.
  it('perform deposit and withdraw without integer overflow', async function () {
    const depositAmount = ethers.utils.parseEther("50");
    const withdrawAmount = ethers.utils.parseEther("30");

    // Check the initial balance of the contract 
    const initialBalance = await integerOverflowVulnerabilityExample.balance();
    console.log('Initial balance of the contract:', ethers.utils.formatUnits(initialBalance, "ether"), 'ETH');

    console.log('Performing deposit...');
    await integerOverflowVulnerabilityExample.deposit(depositAmount);

    // Check the balance after the deposit and log it.
    const balanceAfterDeposit = await integerOverflowVulnerabilityExample.balance();
    console.log('Balance after deposit:', ethers.utils.formatUnits(balanceAfterDeposit, "ether"), 'ETH');

    console.log('Performing withdraw...');
    await integerOverflowVulnerabilityExample.withdraw(withdrawAmount);

    // Check the final balance and log it.
    const finalBalance = await integerOverflowVulnerabilityExample.balance();
    console.log('Final balance:', ethers.utils.formatUnits(finalBalance, "ether"), 'ETH');

    // Assert that the initial and final balances are as expected.
    assert.equal(initialBalance.toString(), initialBalance.toString(), 'Initial balance is not correct');
    assert.equal(finalBalance.toString(), balanceAfterDeposit.sub(withdrawAmount).toString(), 'Final balance is not correct');
  });

  // Test case: Simulate an integer overflow attack.
  it('simulate an integer overflow attack', async function () {
    console.log('Performing large deposit...');
    const depositAmount = ethers.utils.parseEther("200"); // Choose a large deposit amount

    // Perform a deposit with the large amount.
    await integerOverflowVulnerabilityExample.deposit(depositAmount);
    const initialBalance = await integerOverflowVulnerabilityExample.balance();

    console.log('Balance after large deposit:', ethers.utils.formatUnits(initialBalance, "ether"), 'ETH');

    console.log('Attempting to withdraw 221.0 ETH...');
    const withdrawAmount = ethers.utils.parseEther("221"); // Withdraw more than the deposited amount

    // Attempt to withdraw an amount that would cause an overflow, but it should revert.
    try {
      await integerOverflowVulnerabilityExample.withdraw(withdrawAmount);
    } catch (error) {
      // Catch the revert error.
      assert(error.message.includes('revert'), 'Expected a revert error');
    }

    // Verify that the balance hasn't changed.
    const finalBalance = await integerOverflowVulnerabilityExample.balance();
    console.log('Final balance:', ethers.utils.formatUnits(finalBalance, "ether"), 'ETH');
  });
});
