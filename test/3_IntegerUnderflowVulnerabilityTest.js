// Import necessary modules and libraries.
const { ethers, upgrades } = require('hardhat');
const { assert } = require('chai');
const { utils } = require('ethers');

// Start defining your test suite.
describe('Integer Underflow Simulation', function () {
  let integerUnderflowVulnerabilityExample;
  let owner;

  // Before running the tests, deploy the contract and set up initial conditions.
  before(async function () {
    [owner] = await ethers.getSigners();

    // Deploy the contract and assign the instance to a variable.
    console.log('Deploying IntegerUnderflowVulnerabilityExample contract...');
    const IntegerUnderflowVulnerabilityExample = await ethers.getContractFactory('IntegerUnderflowVulnerabilityExample');
    integerUnderflowVulnerabilityExample = await IntegerUnderflowVulnerabilityExample.deploy();
    await integerUnderflowVulnerabilityExample.deployed();
  });

  // Test case: Perform deposit and withdraw without causing an integer underflow.
  it('perform deposit and withdraw without integer underflow', async function () {
    const depositAmount = ethers.utils.parseEther("100");
    const withdrawAmount = ethers.utils.parseEther("99.99");

    // Get the initial balance of the owner.
    const initialBalance = await integerUnderflowVulnerabilityExample.balances(owner.address);
    console.log('Initial balance of the contract:', ethers.utils.formatUnits(initialBalance, "ether"), 'ETH');

    console.log('Performing deposit...');
    await integerUnderflowVulnerabilityExample.connect(owner).deposit({ value: depositAmount });

    // Check the updated balance.
    const newBalanceAfterDeposit = await integerUnderflowVulnerabilityExample.balances(owner.address);
    console.log('Balance after deposit:', ethers.utils.formatUnits(newBalanceAfterDeposit, "ether"), 'ETH');
    assert.equal(newBalanceAfterDeposit.toString(), initialBalance.add(depositAmount).toString(), 'Deposit succeeded');

    console.log('Performing withdraw...');
    await integerUnderflowVulnerabilityExample.connect(owner).withdraw(withdrawAmount);

    // Check the final balance after withdrawal.
    const finalBalanceAfterWithdrawal = await integerUnderflowVulnerabilityExample.balances(owner.address);
    console.log('Final balance:', ethers.utils.formatUnits(finalBalanceAfterWithdrawal, "ether"), 'ETH');
    assert.equal(finalBalanceAfterWithdrawal.toString(), newBalanceAfterDeposit.sub(withdrawAmount).toString(), 'Withdrawal succeeded');
  });

  // Test case: Attempt to simulate an integer underflow on withdraw.
  it('simulate an integer underflow attack', async function () {
    // Attempt to withdraw an amount greater than the balance.
    const withdrawAmount = ethers.utils.parseEther("110");

    // Get the initial balance of the owner.
    const initialBalance = await integerUnderflowVulnerabilityExample.balances(owner.address);

    console.log('Attempting to withdraw 110.0 ETH...');
    try {
      await integerUnderflowVulnerabilityExample.connect(owner).withdraw(withdrawAmount);
    } catch (error) {
      // Check if the transaction failed.
      assert.isTrue(error.message.includes("failed"), "Expected error message indicating transaction failure");
    }

    // Verify that the balance hasn't changed.
    const finalBalanceAfterFailedWithdrawal = await integerUnderflowVulnerabilityExample.balances(owner.address);
    console.log('Final balance:', ethers.utils.formatUnits(finalBalanceAfterFailedWithdrawal, "ether"), 'ETH');
    assert.equal(finalBalanceAfterFailedWithdrawal.toString(), initialBalance.toString(), 'Balance should remain unchanged after a failed withdrawal');
  });
});
